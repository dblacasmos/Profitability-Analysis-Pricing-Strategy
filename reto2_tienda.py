# -*- coding: utf-8 -*-
"""Reto2-Tienda.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ytjVVqBcGPrgfE3nt5SjuHtWlQoUZHqJ

## **1. IMPORTACIONES Y CONFIGURACIÓN INICIAL**
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
sns.set_style('darkgrid')

"""*   **import numpy as np** -> Importa Numpy con alias np. Usado para operaciones numéricas.
*   **import pandas as pd** -> Importa Pandas como pd para trabajar con dataframes.
*   **import matplotlib.pyplot as plt** -> Módulo de gráficos básicos de Matplotlib.
*   **%matplotlib inline** -> Hace que los gráficos se vean dentro del notebook.
*   **import seaborn as sns** -> Importa Seaborn para gráficos estadísticos bonitos.
*   **sns.set_style('darkgrid')** -> Estilo visual de los gráficos: fondo gris con rejilla.

## **2. CARGA DEL DATASET (Store.csv)**
"""

from pandas.core.reshape import encoding
df=pd.read_csv ('Store.csv',
               encoding = 'ISO-8859-1',
               parse_dates=['Order Date', 'Ship Date'])
df.head()

"""*  **pd.read_csv(...)**
   *  Lee el CSV desde esa ruta.
   *  **encoding='ISO-8859-1'** -> para soportar carácteres especiales.
   *  **parse_dates=['Order Date','Ship Date']** -> convierte esas columnas a tipo fecha.
*  **df** -> DataFrame principal con todos los datos.
*  **df.head()** -> Muestra las primeras filas para ver como es la tabla.

## **3. VISTA RÁPIDA DEL DATAFRAME**
"""

df.info()

"""
*   Muestra:
    *   nº filas y columnas,
    *   tipo de cada columna,
    *   si hay nulos.

"""

df.describe()

"""*   Estadísticas de columnas numéricas: media, desviación estándar, min, max, porcentajes, etc."""

df.describe(include='object')

"""*   Estadísticas de columnas catégoricas (tipo object): count, nº de valores únicos, valor más frecuente, frecuencia.

## **4. LIMPIEZA BÁSICA**

### **DATA CLEANING**
"""

df.duplicated().sum()

"""*   **df.duplicated().sum()** -> Cuenta cuántas filas duplicadas hay en el DataFrame."""

df.drop_duplicates(inplace=True)

"""*   Elimina filas duplicadas.
*   **inplace=True** -> modifica df directamente.
"""

df.isna().sum()
# No hay valores nulos

"""*   **df.isna().sum()** -> Cuenta nulos por columna.
*   El comentario nos indica que no hay valores nulos.

## **5. FEATURE ENGINEERING BÁSICO**

### **Fiture_engineering**
"""

df['Cost']=df['Sales']-df['Profit']
df['profit_margin']=(df['Profit']/df['Sales'])*100

"""*   **df['Cost']** -> Crea una columna de coste:
    *   Coste≈Ventas - Beneficio.
*   **df['profit_margin']** -> Margen de beneficio en %:
    *   (Profit/Sales)*100.
"""

df['is_gain']=np.where(df['Profit']>0,1,0)

"""*   **np.where(condición, valor_si_True, valor_si_False)**
*   Crea columna binaria:
    *   1 si **Profit > 0** (ganancia),
    *   0 si **Profit ≤ 0** (pérdida).
"""

df['Days_to_ship']=(df['Ship Date']-df['Order Date']).dt.days.astype(int)

"""*   Resta fechas (Fecha pedido - Fecha envío) -> **Timedelta** (es un object de un intervalo de tiempo).
*   **.dt.days** -> Convierte el Timedelta a nº de días.
*   **.astype(int)** -> asegura tipo entero.
*   **df['Days_to_ship']** -> Crea días que tarda en enviarse.

"""

df['sales_per_quantity']=df['Sales']/df['Quantity']

"""*   **df['sales_per_quantity']** -> Crea **"precio medio por unidad"**: ventas totales/cantidad."""

df['month_order']=df['Order Date'].dt.month
df['year_order']=df['Order Date'].dt.year

"""*   Extrae mes y año de la fecha de pedido."""

df.columns

"""*   Muestra todas las columnas del DataFrame."""

len(df.columns)

"""*   Cuenta cuántas columnas hay.

## **6. PREPARACIÓN Y PRIMEROS EDA**

### **EDA & Visualization**
"""

df_used=df[['Row ID','Ship Mode','Customer Name','Segment','City',
            'State','Country','Region','Category','Sub-Category',
            'Product Name','Sales','Quantity','Discount','Cost',
            'Profit','profit_margin','is_gain','Days_to_ship',
            'sales_per_quantity','month_order','year_order']]
df_used.set_index('Row ID',inplace=True)
df_used.head()

"""*   **df_used=df[[...]]** -> Crea un subconjunto con las columnas que vas a usar.
*   **set_index('Row ID')** -> Pone **Row ID** como índice (identificador único).
*   **df_used.head()** -> vista rápida.
"""

# Suma de Ventas
sum_sales=df_used['Sales'].sum()

# Suma de Ganancias
sum_profit=df_used['Profit'].sum()

# Suma de Costes
sum_cost=df_used['Cost'].sum()

# Suma de Cantidades
sum_quantity=df_used['Quantity'].sum()

# Suma de Descuentos
sum_discount=df_used['Discount'].sum()

print('sum_sales:',sum_sales)
print('sum_profit:',sum_profit)
print('sum_cost:',sum_cost)
print('sum_quantity:',sum_quantity)
print('sum_discount:',sum_discount)

"""*   Calcula la suma total de:
    *   ventas, beneficios, costes, cantidades y descuentos.
*   Guarda cada suma en una variable.
*   Imprime todas las sumas totales.
"""

bars=plt.bar(['sum_sales','sum_profit','sum_cost'],
             [sum_sales,sum_profit,sum_cost],
             color=['#777C6D','#B7B89F','#CBCBCB'])
plt.title('sum of sales, profit and cost')
ax=plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.bar_label(bars)
plt.show()

"""*   **plt.bar(...)** -> Gráfico de barras con las tres sumas totales.
*   **plt.title(...)** -> Título del gráfico.
*   **plt.gca()** -> Obtiene los ejes actuales.
*   **ax.spines[...]** -> Oculta bordes superior y derecho para estética.
*   **plt.bar_label(bars)** -> Pone etiquetas con los valores encima de cada barra.
*   **plt.show()** -> Muestra el gráfico.
"""

total_profit_margin=(sum_profit/sum_sales)*100
total_profit_margin

"""*   Calcula el margen de beneficio total en %.
*   **total_profit_margin** -> Muestra el valor.
"""

sns.countplot(data=df_used,x='Category',hue='Category', palette='Blues')
plt.title('Category')
plt.show()

"""*   **sns.countplot** -> Cuenta cuántos registros hay por categoría.
*   Eje X: **Category**.
*   **palette='Blues'** -> Colores azules.
*   Título del gráfico.
*   **show** -> Muestra que **Office Supplies** es la más frecuente.
"""

sales_furnitur=df.loc[df['Category']=='Furniture','Sales'].sum()
sales_office=df.loc[df['Category']=='Office Supplies','Sales'].sum()
sales_technology=df.loc[df['Category']=='Technology','Sales'].sum()

print('sales_furnitur:',sales_furnitur)
print('sales_office:',sales_office)
print('sales_technology:',sales_technology)

profit_furnitur=df.loc[df['Category']=='Furniture','Profit'].sum()
profit_office=df.loc[df['Category']=='Office Supplies','Profit'].sum()
profit_technology=df.loc[df['Category']=='Technology','Profit'].sum()

print(50*'-')

print('profit_furnitur:',profit_furnitur)
print('profit_office:',profit_office)
print('profit_technology:',profit_technology)

"""*   **df['Category']=='...'** -> Crea un filtro booleano por categoría.
*   **df.loc[filtro, 'Sales']** -> Selecciona las filas donde **Category = '...'**
*   **.sum()** -> Suma esas **'Sales'** de la selección **'...'**
*   Imprime las ventas totales de los tres resultados.
*   Mismo estructura para **'Profit'**.
"""

fig,ax=plt.subplots(1,2)
ax[0].pie([sales_furnitur,sales_office,sales_technology],
          labels=['furnitur','office','technology'],
          colors=['#BF092F','#132440','#16476A'],
          autopct='%1.1f%%')
ax[0].set_title('sales by category')

ax[1].pie([profit_furnitur,profit_office,profit_technology],
          labels=['furnitur','office','technology'],
          colors=['#BF092F','#132440','#16476A'],
          autopct='%1.1f%%',
          explode=[0.2,0,0])
ax[1].set_title('profit by category')

plt.show()

"""*   **fig.ax=plt.subplots(1,2)** -> Crea una figura con dos subgráficos en una fila.
*   Primer gráfico **(ax[0])**: pastel de ventas por categoría.
*   Segundo **(ax[1])**: pastel de beneficios por categoría.
*   **explode[0.2,0,0]** -> Resalta la primera porción (Furniture).
*   **plt.show()** -> Muestra ambos gráficos.
"""

sns.countplot(data=df_used,x='Sub-Category',hue='Sub-Category', palette='Blues',legend=False)
plt.title('Sub-Category')
plt.xticks(rotation=90)
plt.show()

"""*   Countplot por subcategoría.
*   **plt.xticks(rotation=90)** -> Rota etiquetas 90º para que quepan.
"""

order1=df_used.groupby('Sub-Category')['Sales'].sum().sort_values(ascending=False)
order2=df_used.groupby('Sub-Category')['Profit'].sum().sort_values(ascending=False)

"""*   **df_used.groupby('Sub-Category')** -> Agrupar las filas por subcategoría:
    *   **order1='Sales'.sum()** -> Por cada grupo de subcategoría suma ventas.
    *   **order2='Profit'.sum()** -> Por cada grupo de subcategoría suma ganancias.
    *   **.sort_values(ascending=False**) -> Ordena de mayor a menor.
*   se guardan en las variables para usarlo en gráficos posteriores.
"""

plt.figure(1)
sns.barplot(data=df_used,x='Sub-Category',y='Sales',hue='Sub-Category',
            palette='YlGnBu',legend=False,order=order1.index,estimator='sum')
plt.title('Sales by Sub-Category')
plt.xticks(rotation=90)

plt.figure(2)
sns.barplot(data=df_used,x='Sub-Category',y='Profit',hue='Sub-Category',
            palette='YlGnBu',legend=False,order=order2.index,estimator='sum')
plt.title('Profit by Sub-Category')
plt.xticks(rotation=90)
plt.show()

"""*   Creamos dos gráficos:
    *   Primero: barra de ventas por subcategoría.
    *   Segundo: barra de ganancias por subcategoría.
    *   **order=order1.index/order2.index** -> Ordena de mayor a menor.
    *   **estimator='sum'** -> Usa la suma como medida.
"""

sns.scatterplot(data=df_used,x='Discount',y='Profit',hue='Category',palette='YlGnBu')
plt.title('Discount vs Profit')
plt.show()

"""*   Dispersión descuento vs beneficio."""

sns.scatterplot(data=df_used,x='Discount',y='Sales',hue='Category',palette='YlGnBu')
plt.title('Discount vs Sales')
plt.show()

"""*   Dispersión descuento vs ventas

## **7. EDA POR CIUDAD, ESTADO, REGIÓN Y TIEMPO**
"""

sales_for_cities=df_used.pivot_table(index='City', values='Sales',aggfunc='sum').sort_values(by='Sales',ascending=False)
sales_for_cities=sales_for_cities.head(15)
sales_for_cities

"""*   **df_used.pivot_table** -> Crea una tabla dinámica.
    *   Filas: **index='City'** (ciudades).
    *   Valor: **values='Sales',aggfunc='sum'** (suma de ventas).
*   Ordena de mayor a menor por **'Sales'**.
*   Muestra el resultado.
"""

bars=sns.barplot(data=sales_for_cities,x=sales_for_cities.index,y='Sales',color='red')
bars.patches[0].set_hatch('/')
plt.title('top 15 Sales for City')
plt.xticks(rotation=90)
plt.show()

"""*   Gráfico de barras con las 15 ciudades con más ventas.
*   **bars.patches[0].set_hatch('/')** -> Pone la primera barra "rayada" para destacarla.
"""

sales_for_state=df_used.pivot_table(index='State',values='Sales',aggfunc='sum').sort_values(by='Sales',ascending=False)
sales_for_state=sales_for_state.head(15)
sales_for_state

"""*   Igual pero con estado (state)."""

bars=sns.barplot(data=sales_for_state,x=sales_for_state.index,y='Sales',color='blue')
bars.patches[0].set_hatch('/')
plt.title('top 15 Sales for State')
plt.xticks(rotation=90)
plt.show()

"""*   Gráfico de barras de venta por estado(top 15)."""

sales_for_region=df_used.pivot_table(index='Region',values='Sales',aggfunc='sum').sort_values(by='Sales',ascending=False)
sales_for_region

"""*   Ventas totales por región."""

plt.pie(sales_for_region['Sales'],labels=sales_for_region.index,
        autopct='%1.1f%%',
        colors=['#BF092F','#BADFDB','#16476A','#3B9797'])
plt.title('Sales for Region')
plt.show()

"""*   Gráfico de pastel de ventas por región."""

top_20_customer=df_used.pivot_table(index='Customer Name',values='Sales',aggfunc='sum').sort_values(by='Sales',ascending=False)
top_20_customer=top_20_customer.head(20)
top_20_customer

"""*   Clientes ordenados de mayor a menor por ventas, top 20."""

sales_for_product=df_used.pivot_table(index='Product Name',values='Sales',aggfunc=['sum','count'])
sales_for_product=sales_for_product.sort_values(by=('sum','Sales'),ascending=False)
sales_for_product.head(20)

"""*   Tabla dinámica por producto:
    *   suma de ventas(**sum**) y nº de apariciones(**count**).
Ordena por suma de ventas descendente y muestra los 20 primeros.
"""

profit_for_product=df_used.pivot_table(index='Product Name',values='Profit',aggfunc=['sum','count'])
profit_for_product=profit_for_product.sort_values(by=('sum','Profit'),ascending=False)
profit_for_product.head(20)

"""*   Igual que el anterior pero con beneficios."""

profit_for_product=df_used.pivot_table(index='Product Name',values='Profit',aggfunc=['sum','count'])
profit_for_product=profit_for_product.sort_values(by=('sum','Profit'),ascending=True)
profit_for_product.head(20)

"""*   **ascending=True** -> Ordena de menor a mayor beneficio(productos que más pierden)"""

sales_for_year_cat=df_used.groupby(['year_order','Category'],as_index=False)['Sales'].sum()
sales_for_year_cat

"""*   Agrupa por año y categoría la suma de ventas."""

g=sns.relplot(data=sales_for_year_cat,x='year_order',y='Sales',
              kind='line',color='blue',col='Category', marker='o')
g.fig.suptitle('Sales by year and Category',y=1.05)
plt.show()

"""*   **sns.relplot(...)** -> Gráfico de relación de Seaborn, da una figura con uno o varios subgráficos.
*   **kind='line'** -> Le dice a Seaborn que quiere una gráfica de líneas.
*   **col='Category'** -> Divide el gráfico en columnas, una por categoría(facet grid), un gráfico por cada columna.
*   **marker='o'** -> Añade puntos en cada valor de la línea por estética.
*   **g.fig.suptitle('Sales by year and Category',year=1.05)**:
    *   **sns.relplot** devuelve un objeto **g**.
    *   **g.fig** es la figura completa.
    *   **suptitle**="super title"=título general para toda la figura.
    *   **y=1.05** ajusta la posición vertical para que el título no quede encima de los gráficos.

## **8. EDA POR MESES, SEGMENTOS, SHIPPING, ETC**
"""

sales_by_month=df_used.groupby(['month_order','year_order'], as_index=False)['Sales'].sum()
sales_by_month

"""*   Ventas agrupadas por mes y año."""

g=sns.relplot(data=sales_by_month,x='month_order',y='Sales',
              kind='line',color='green',col='year_order', marker='o')
g.fig.suptitle('Sum of Sales by months',y=1.05)
plt.show()

"""*   Gráfico lineal de cada año mostrando ventas por mes."""

sales_year=df_used.pivot_table(index='year_order',values=['Sales','Profit'],aggfunc='sum')
sales_year.sort_values(by='Sales',ascending=False)

"""*   Ventas y beneficios totales por año.
*   Ordena de mayor a menor venta.
"""

sales_mon=df_used.pivot_table(index='month_order',values='Sales',columns='year_order',aggfunc='sum',margins=True)
sales_mon

"""*   Tabla tipo "matriz":
    *   Cada fila es un mes.
    *   Sales es lo que quiero calcular.
    *   Cada columna será un año diferente.
    *   **margins=True** -> Añade una fila y una columna extra llamadas **All**:
        *   La **fila All** muestra la suma total por columna(ventas totales por año).
        *   La **columna All** muestra la suma total por fila(ventas totales en un mes sumando todos los años).
"""

fig,ax=plt.subplots(1,2)
ax[0].pie(sales_year['Sales'],labels=sales_year.index,
          autopct='%1.1f%%',
          colors=['#BF092F','#BADFDB','#16476A','#3B9797'])
ax[0].set_title('Sales by year')

ax[1].pie(sales_year['Profit'],labels=sales_year.index,
          autopct='%1.1f%%',
          colors=['#BF092F','#BADFDB','#16476A','#3B9797'])
ax[1].set_title('Profit by year')

plt.show()

"""*   Dos gráficos de pastel con distribución por ventas y beneficios por año."""

sns.countplot(data=df_used,x='Days_to_ship',hue='Days_to_ship', palette='Greens')
plt.title('Days to ship')
plt.show()

"""*   Muestra cuántos pedidos tardan X días en enviarse."""

sales_state=df.groupby(['State','Category'])['Sales'].sum().sort_values(ascending=False).reset_index()
sales_state=sales_state.head(20)
sales_state

"""*   Agrupa ventas por estado y categoría.
*   Ordena descendentemente y toma top 20 combinaciones.
"""

g=sns.catplot(data=sales_state,x='State',y='Sales',
              kind='bar', color='red',col='Category')
g.fig.suptitle('Sales by State and Category',y=1.05)
g.set_xticklabels(rotation=90)
plt.show()

"""*   **sns.catplot** -> Tipo de gráfico de Seaborn para visualizar **categorías**.
*   **kind='bar'** -> Indica que el gráfico será de barras.
*   **col='Category'** -> Haz un gráfico separado para cada categoría.
"""

sales_state=df.groupby(['Region','Category'])['Sales'].sum().sort_values(ascending=False).reset_index()
sales_state=sales_state.head(20)
sales_state

"""*   Igual pero agrupando por región + categoría."""

g=sns.catplot(data=sales_state,x='Region',y='Sales',
              kind='bar',color='red',col='Category')
g.fig.suptitle('Sales by Region and Category',y=1.05)
g.set_xticklabels(rotation=90)
plt.show()

"""*   Gráfico de barras por región y categoría."""

bars=sns.barplot(data=df_used,x='Region',y='Profit',color='red',estimator=np.sum)
plt.title('Profits by Region')
plt.show()

"""*   Suma de beneficio total por región.
*   **estimator=np.sum** -> Indica como calcular cada barra, por defecto es **estimator=np.mean**.
"""

sns.countplot(data=df_used,x='Segment',hue='Segment',palette='Greens')
plt.title('Segment')
plt.show()

"""*   Cuenta cuántos registros hay en cada segmento(Consumer,Corporate,etc)."""

df_used.pivot_table(index='Segment',values='Sales',aggfunc='sum').sort_values(by='Sales',ascending=False)

"""*   Ventas por segmento, ordenadas de mayor a menor."""

df_used.pivot_table(index='Segment',values='Profit',aggfunc='sum').sort_values(by='Profit',ascending=False)

"""*   Beneficio por segmento."""

sns.barplot(data=df_used,x='Segment',y='Sales',
            hue='Category',palette='Greens',estimator=sum)
plt.title('Sales by Segment')
plt.show()

"""*   Gráfico de barras apiladas por segmento y categoría(sales)."""

sns.barplot(data=df_used,x='Segment',y='Sales',
            hue='Region',palette='Greens',estimator=sum)
plt.title('Sales by Segment')
plt.show()

"""*   Similar pero separa por región."""

sns.scatterplot(data=df_used,x='Quantity',y='Profit',hue='Category',palette='Greens')
plt.title('Quantity vs Profit')
plt.show()

"""*   Dispersión cantidad vs beneficio, coloreado por categoría.
*   **sns.scatterplot** -> Gráfico de dispersión en Seaborn por puntos.

## **9. SHIP MODE, DISTRIBUCIONES Y CORRELACIÓN**
"""

sns.countplot(data=df_used,x='Ship Mode',hue='Ship Mode',palette='Greens')
plt.title('Ship Mode')
plt.show()

"""*   Cuenta cuántos pedidos van por cada modo de envío(Standard,Second Class,etc)."""

plt.figure(1)
sns.barplot(data=df_used,x='Ship Mode',y='Sales',hue='Ship Mode',
            palette='Greens',estimator=sum)
plt.title('Sales by Ship Mode')

plt.figure(2)
sns.barplot(data=df_used,x='Ship Mode',y='Profit',hue='Ship Mode',
            palette='Greens',estimator=sum)
plt.title('Profit by Ship Mode')
plt.show()

"""*   **plt.figure(1)** -> Gráfico 1: ventas por modo de envío.
*   **plt.figure(2)** -> Gráfico 2: beneficios por modo de envío.
"""

sns.boxplot(data=df_used,x='Ship Mode',y='Days_to_ship',hue='Days_to_ship',palette='Greens')
plt.title('Days to ship by Ship Mode')
plt.show()

"""*   **sns.boxplot** -> Gráfico de cajas de Seaborn.
*   Boxplot del nº de días para enviar según el modo de envío.
"""

count_gain=df_used.groupby('is_gain').size().reset_index(name='count')
plt.pie(count_gain['count'],labels=count_gain['is_gain'],
        autopct='%1.1f%%',colors=['#F25912','#5C3E94'])
plt.title('is_gain')
plt.legend(['0: loss','1: gain'])
plt.show()

"""*   **df_used.groupby('is_gain')** -> Agrupa el dataframe por la columna is_gain.
*   **is_gain** tiene valores:
    *   1 -> el pedido generó beneficio.
    *   0 -> el pedido generó pérdida.
*   **groupby** crea dos grupos:
    *   Grupo 0: todas las filas donde **is_gain=0**.
    *   Grupo 1:todas las filas donde **is_gain=1**.
*   **size()** -> Cuenta cuántas filas hay en cada grupo.
*   **.reset_index(name='count')** -> Convierte ese dataframe ordenado con dos columnas y se guarda en la variable count_gain.
*   **count_gain['count']** -> Son los nº que va a usar para calcular el tamaño de la pòrción en el gráfico de pastel.
*   **labels=count_gain['is_gain']** -> Etiquetas en el pastel(**0 ó 1**).
*   **plt.legend(['0: loss','1: gain'])** -> Añade leyenda manual para que se explique mejor.
"""

sns.histplot(data=df_used,x='Sales',color='green')
plt.title('Sales')
plt.show()

"""*   **sns.histplot** -> Histograma de Seaborn.
*   Crea un histograma de ventas.
"""

sns.boxplot(data=df_used,x='Category',y='Sales',hue='Category',palette='Reds')
plt.title('Sales by Category')
plt.show()

"""*   Boxplot de ventas por categoría."""

sns.stripplot(data=df_used,x='Category',y='Sales',hue='Category',palette='Reds')
plt.title('Sales by Category')
plt.show()

"""*   **sns.stripplot** -> Gráfico de puntos donde cada punto representa una fila del dataset.

"""

sns.violinplot(data=df_used,x='Category',y='Sales',hue='Category',palette='Reds')
plt.title('Sales by Category')
plt.show()

"""*   **sns.violinplot** -> Gráfico que muestra la forma de distribución(igual a un histograma), pero vertical y suavizado."""

plt.figure(figsize=(10,8))
sns.heatmap(df_used.corr(numeric_only=True),annot=True,cmap='Blues',fmt='.1g')
plt.title('Correlation')
plt.show()

"""*   **plt.figure(figsize=(10,8))** -> Crea una figura nueva con tamaño en pulgadas 10(ancho) y 8(alto).
*   **sns.heatmap(...)** -> Dibuja un **mapa de calor** de una matriz. Los colores indican qué tan fuerte es la correlación:
    *   más azul oscuro = alta correlación.
    *   más claro = baja correlación.
*   **df_used.corr(numeric_only=True)**
    *   Calcula la **matriz de correlación** del dataframe,(tabla que muestra como se relaciona una variable con otra).
    *   Solamente usa columnas numéricas.
    *   Relaciones correlación:
        *   **1.0**  -> correlación perfecta positiva.
        *   **-1.0** -> correlación perfecta negativa.
        *   **0.0**  -> no relación.
*   **annot=True** -> **"annotation"** = poner los valores numéricos encima de cada celda,(con esto ves números aparte de colores).
*   **cmap='Blues'** -> Colormap en tonos en azul.
*   **fmt='.1g'** -> Formato de los nº de cada celda(un dígito significativo).

## **10. EDA AUTOMÁTICO (YDATA-PROFILING)**
"""

#Instalar lib ydata-profiling
!pip install ydata-profiling

try:
  from ydata_profiling import ProfileReport

  profile=ProfileReport(
      df,
      title='EDA Automático - Store',
      explorative=True
      )
  profile.to_file('eda_automatico_store.html')
  print('Informe generado: eda_automatico_store.html')
except Exception as e:
  print('No se pudo generar el perfil automático. Error:')
  print(e)

"""*   Instala librería **ydata-profiling**.
*   Intenta importar **ProfileReport**.
*   **ProfileReport(...)** genera un informe EDA completo:
    *   Distribuciones,nulos,correlaciones,etc.
*   **to_file(...)** -> guarda el informe en HTML
*   Si falla captura la excepción y la imprime.

## **11. INGENIERÍA DE CARACTERÍSTICAS Y PREPARACIÓN PARA ML (SCIKIT-LEARN)**

### **11.1. Selección de atributos(scikit-learn)**
"""

from sklearn.feature_selection import SelectKBest, f_regression
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import numpy as np
import pandas as pd

# Aseguramos que trabajamos con columnas numéricas y la existencia de Profit
if 'Profit' in df.columns:
  X_num = df.select_dtypes(include=['number']).drop(columns=['Profit'])
  y = df['Profit']

  # Rellenamos de manera sencilla los nulos
  X_num = X_num.fillna(X_num.median())

  # 1.- SelectKBest (relación lineal)
  selector = SelectKBest(score_func=f_regression, k=min(5, X_num.shape[1]))
  selector.fit(X_num, y)
  selected_cols_kbest = X_num.columns[selector.get_support()].tolist()
  print('Top mejores columnas numéricas según SelectKBest:', selected_cols_kbest)

  # 2.- Importancia de características con RandomForest (no lineal)
  rf = RandomForestRegressor(n_estimators=100, random_state=42)
  rf.fit(X_num, y)
  importances = pd.Series(rf.feature_importances_, index=X_num.columns).sort_values(ascending=False)
  print('\nTop Importancia de variables númericas (RandomForest):')
  print(importances.head(10))
else:
  print('No se encontró la columna Profit en el dataframe')

"""*   Importa de **scikit-learn**(**sklearn**)
    *   **SelectKBest**, **f_regression** -> selección de variables basada en relación lineal con la **y**.
    *   **RandomForestRegressor** -> modelo de bosque aleatorio para estimar la importancia de variables.
    *   **train_test_split** -> dividir en train/test.
    *   **StandardScaler** -> escalado estándar.
*   Comprueba que **Profit** existe.
*   **X_num = df.select_dtypes(includeÇ=['number']).drop(columns=['Profit'])** -> Toma solo columnas numéricas y quita Profit(objetivo).
*   **y = df['Profit']** -> variable objetivo.
*   **X_num = X_num.fillna(X_num.median())** -> rellena nulos con la mediana.
*   **SelectKBest(...)**:
    *   **score_func=f_regression** -> usa F-test de regresión.
    *   **k=min(5,X_num.shape[1])** -> selecciona hasta 5 mejores columnas.
*   **selector.fit(X_num, y)** -> ajusta la selección al dato.
*   **selector.get_support()** -> máscara booleana de columnas seleccionadas.
*   **RandomForestRegressor(...)** -> modelo no lineal para ver importancias.
*   **rf.fit(X_num, y)** -> entrena el modelo.
*   **rf.feature_importances_** -> peso de cada variable.
*   **pd.Series(...)sort_values(...)** -> ordena importancias.
*   Imprime top columnas.

### **11.2. Transformaciones (log y escalado)**
"""

# Transformación logarítmica de Sales
if 'Sales' in df.columns:
  df['Sales_log'] = np.log1p(df['Sales'])
  print(df[['Sales','Sales_log']].head())

# Escalado estándar de Profit
if 'Profit' in df.columns:
  scaler = StandardScaler()
  df['Profit_scaled'] = scaler.fit_transform(df[['Profit']])
  print(df[['Profit','Profit_scaled']].head())

"""*   **np.log1p(x)** -> aplica log(1 + x) para estabilizar distribuciones muy sesgadas.
*   Crea **Sales log**.
*   **StandarScaler()** -> consiste en que Profit tenga media 0 y varianza 1.
*   **fit_transform** -> aprende media/desviación y transforma los datos.
*   Imprimen tanto la transformación como el escalado estándar.

### **11.3. Nuevos atributos**
"""

# Atributo 1: margen de beneficio si no existiera
if 'Sales' in df.columns and 'Profit' in df.columns:
  if 'Profit_Margin' not in df.columns and 'profit_margin' not in df.columns:
    df['Profit_Margin'] = df['Profit'] / df['Sales']
    print(df[['Sales','Profit','Profit_Margin']].head())
  else:
    print('Ya existe una columna de margen de beneficio (Profit_Margin / profit_margin')

# Atributo 2: nivel de descuento (bajo/medio/alto)
if 'Discount' in df.columns:
  df['Discount_Level'] = pd.cut(
      df['Discount'],
      bins=[-0.001,0.1,0.3,1],
      labels=['Bajo','Medio','Alto']
  )
  print(df[['Discount','Discount_Level']].head())

# Atributo 3: variables temporales.
if 'Order Date' in df.columns:
  if not np.issubdtype(df['Order Date'].dtype, np.datetime64):
      df['Order Date'] = pd.to_datetime(df['Order Date'])
  df['Order Year'] = df['Order Date'].dt.year
  df['Order Month'] = df['Order Date'].dt.month
  df['Order DayOfWeek'] = df['Order Date'].dt.dayofweek
  print(df[['Order Date','Order Year','Order Month','Order DayOfWeek']].head())

"""**Atributo 1:**
*   Comprobación de que el DataFrame contenga **Sales** y **Profit**.
*   Evita duplicados si ya existiera **Profit_Margin** o **profit_margin**.
*   Margen de beneficio = beneficio / ventas.
*   Imprime las 5 primeras líneas.

**Atributo 2:**
*   Comprobación de que exista Discount.
*   **pd.cut(df['Discount'],bins[-0.001,0.1,0.3,1],labels=['Bajo','Medio','Alto'])** -> Se categoriza el descuento en 3 niveles.
    *   **pd.cut** divide un valor numérico en rangos(bins).
        *   **-0.001 - 0.1** -> 'Bajo'.
        *   **0.1 - 0.3** -> 'Medio'.
        *   **0.3 - 1** -> 'Alto'.
Esto convierte el descuento en una variable categorical, ideal para modelos ML.
*   Muestra las 5 primeras filas.

**Atributo 3:**
*   Comprueba que existe **Order Date**
*   **if not np.issubdtype(df['Order Date'].dtype, np.datetime64)**:
    *   Si la columna **Order Date** no está en formato fecha entonces la convierte con **pd.to_datatime**.
    *   Si Order Date fuera texto no se podría extraer año, mes, etc.
*   Crea columnas para:
    *   Año (**Order Year**) -> **df['Order Date'].dt.year**
    *   Mes (**Order Month**)-> **df['Order Date'].dt.month**
    *   Día de la semana (**Order DayOfWeek**)-> **df['Order Date'].df.dayofweek**
*   Imprime 5 filas para verificar.

### **11.4. Dataset listo para ML con one-hot + train_test_split**
"""

# Copia para no perder el dataframe original.
data=df.copy()

# Detectar columnas categóricas.
cat_cols = []
for c in ['Category','Sub-Category','Segment','Region']:
  if c in data.columns:
    cat_cols.append(c)

# One-hot enconding.
if cat_cols:
  data = pd.get_dummies(data, columns=cat_cols, drop_first=True)

# Eliminar columnas no numéricas residuales.
data=data.select_dtypes(include=['number'])

# Separar Profit como variable a predecir.
if 'Profit' in data.columns:
  y=data['Profit']
  X=data.drop(columns=['Profit'])

  # Rellenamos nulos por mediana.
  X=X.fillna(X.median())

  # Train/test split
  X_train,X_test,y_train,y_test=train_test_split(
      X,y,
      test_size=0.2,
      random_state=42
  )

  print('Shape X_train:', X_train.shape)
  print('Shape X_test:', X_test.shape)
else:
  print('No se encontro la columna Profit en los datos numéricos codificados')

"""*   data = df.copy() -> copia el dataframe y así trabajamos sobre una copia para no romper la original.
*   Preparamos **cat_cols** como una lista de columnas categóricas a codificar.
*   **if c in data.columns:** -> añade a la lista las que realmente existen.
*   **pd.get_dummies(...,drop_first=True)**:
    *   **One-hot encoding** -> convierte las categorías en columnas 0/1.
    *   **drop_first=True** -> evita multicolinealidad eliminando una categoría por variable.
*   **data.select_dtypes(include=['number'])** -> Se queda con columnas numéricas(dummies, numéricas originales).
*   Comprueba que **Profit** sigue existiendo:
    *   **y=data['Profit']** -> objetivo.
    *   **X=data.drop(columns=['Profit'])** -> variables explicativas.
*   **X.fillna(X.median())** -> rellena nulos numéricos con la mediana y evitamos que el modelo reviente.
*   Usamos **scikit-learn**:
    *   **train_test_split(X,y,test_size=0.2,random_state=42)** -> divide datos en:
        *   80% entrenamiento (**X_train,y_train**).
        *   20% test (**X_test,y_test**).
        *   **random_state=42** -> reproducible, asegura que la división sea siempre igual.
*   Imprime los tamaños  de train y test.
*   Si no se encontrara Profit, muestra un mensaje de error.
"""